已经完成的企业列表页面，+子表
+Chart图

1.企业详情页面中：http://localhost:8080/WeAdmin/MobileWeb/index.html http://localhost:8080/Comps/index.html
 靠左侧，专业列表，员工列表+热度
(1).合作过的院校列表   选修
    涉及到：添加1 teacher、院校table 两个表
    所以合作的院校的列表也是公司所涉及的一个部分，可以是选填项的部分
(2).准备关注企业，
   涉及到学生表，添加一个关注的字段，是一个1,2,3,   因为一个stus可以关注多个企业，而且关注的明细，在学生详情页面中体现。
(3).企业和学生的留言，右下侧
  create 留言表


2.学生详细信息页面
(1).个人详细信息，包括头像....  靠左边
(2).个人的介绍，座右铭  右边的
(3).已选中的企业明细 靠左边
(4).关注的企业列表  靠左边
(5).学生的活动列表，左边下方
   企业的留言

后天系统，只要第一眼看见的table列表，查询的sql简单不了
第一眼看见的table是一个大概的笼统的列表，肯定不能光针对一个、两个table select

3.Teacher： 功能不多，但是功能的难度不小
其一：角色和权限的问题  ，bootstrap模板的时候有些繁琐的，layui想法简易一些(layui)，
其二：学生登录能看见的部分，教师除了choose一个企业专业之外，其他功能都能浏览查看
  比如，学生的列表中点击详细，跳转到学生的详细个人信息（学生查看的企业详细页面搁置）
统计的内容：
(1).本院校的学生和对应的年级，对应所选的企业明细table   5 个table，以学生为主
  stus classes scores projects comps
  charts图
(2).查看学生详细信息，
(3).角色和权限，也就是students和teacher登录，看见的左侧的菜单是不同的
模板会找一定的繁琐了，根据后台的UI样式来采用不同形式的模板样式
springsecurity  权限拦截框架
涉及到现阶段开发，create 3个table
teacher 院校  留言table  2个必须的，教师和留言
(4).批量插入，Excel批量上传insert学生信息记录






本院校的学生和对应的年级，对应所选的企业明细table   5 个table，以学生为主
  stus classes scores projects comps

学生id  name      班级   企业   专业   操作
                                                     链接到学生详细页面，不能出现choose 更改个人选择的企业专业



java服务端的数据加工  简单
sql 根据实际的需求提升 sql开发实力
UI 脚本，体现UI用户体验度 脚本调试....





服务器教师角色：
1.学生选择企业table
2.复杂chart图
3.角色和权限管理，右侧菜单显示效果
4.Excel批量上传学生信息
5.审核企业信息，独立搞定！
   企业上传一个注册后的信息，不是立刻学生就能浏览choose的，
  老师做一个审核，就是企业的注册，和企业被学生选择一专业，是有一个过程的。
  比如：一个企业注册ok，提升"在xx工作日内审核通过，学生可以交流选择，建议完善企业注册信息(也就是上传xxx之类的证书，工商局注册编码...)"
  所以教师角色登录的时候，肯定有一个列表，待审核企业信息资料table，技术角度easy，设置一个comps公司表的状态值，待审核0 审核通过1 被逼2 ...也就是学生登录查看的是状态值是1的企业信息
 审核当前教师登录，查看一个table，待审核状态的table，因为该table最简单的table，也就是公司和专业表，操作按钮，"审核"，如果老师点击审核通过，列表中就没有该公司记录，学生choost的公司记录多一条了。

  总结：功能就是添加一个comps状态字段，待审核，审核ok...  操作button "审核"  ok，update状态值，列表就没有该公司记录了
   学生可以多看到一条公司记录了

 实际开发中，难度是肯定的了， 因为各个学校的情况是不一样的，相对easy的时候，直接院长登录，审核通过，过程很线下的操作(所以comps会添加很多操作字段，比如工商局注册编码，image，tel，法人的name，...)；但是如果相对繁琐和困难的是 学校的审核是有一个流程的，教师，副主任，办公室主任，院长....
6.显示所有学生choose ok并且不能修改的table，出具Excel报表
  首先是一个固定时间的判断，比如2019.09.01以后不能允许学生修改选择企业专业了，但是现在直接老师可以查看一个学生选择企业ok的table，导出Excel  bootstrapTable已经OK的
如果脚本直接导出，那么页面能看见的内容可以导出，table不显示的肯定没法导出。
所以实际开发二进制下载的过程，Excel下载，还得服务端java生成一个Excel，Excel设计需求的样式，文字....

5.6 功能现阶段操作还是比较easy，实际开发，难度是肯定的。


移动端：针对学生选择企业，和企业宣传的，UI核心还是jQuery，or vuejs，没有bootstrap。脚本没有更多的内容，服务端，springmvc @+动态参数，开发很给力。其次移动端  UI超级发挥你的个性美观的想象力，比如朋友圈....
移动端核心还是UI的pk

     
nio，多线程，反射，springioc ssm  -->企业端 layui   oracle  springboot springcloud  vue  python 


4.Excel批量上传学生信息：
  Excel导入和导出，之前是服务端担任的，
  导入 Apache poi 工具包，Excel作为一个二进制文件上传服务端，操作，
  下载，二进制流的模式，
 现在还有些依赖脚本，上传，导出，都是核心脚本完成的。效率高，而且提升我的开发效率，
 poi非常受限于excel版本，脚本上传，有些不受限于Excel版本，

insert into stus (sid,spwd,sname,sdate,s_lid,ssex)value(null,'321','ssf',now(),(select slid from classes where clname='大四 一班'),'女')

Android IOS 操作系统，现阶段移动app主流还是HTML5前端
移动端 HTML5，不是Android程序，就是HTML5的UI
移动端：现阶段纯用Android studio开发的非常少，手机app总体还是Android studio发布的，
             现阶段很多企业mobile app开发 是Android studio的开发外壳，内在的操作主页面，操作的详细效果等，都是HTML5为主了
             因为1.之前的很多手机app 还是Android的程序的。 所以根本本质改变发布程序，转变需要很多开发环境的变化，所以变化不是很大 2.Android手机开发，确实UI和浏览的效果，不如HTML5，而且HTML5的自适应兼容不同尺寸的移动端设备，所以内在的核心操作逻辑HTML5为主了 3.毕竟HTML5本质是一个web网页，不是一个app，Android 是一个app 程序，所以二者还是本质区别的，但是二者相互不能干扰这个app就是上成的了，HTML5虽然现在主流，但是缺点也是明显的：
   (1)，拍照，传输音频，视频录制... Android app，HTML5就费劲了，HTML5是受限于浏览器的，Android的app 做这类事情easy
   (2).  HTML5自适应"智能瘦身"改变了前端开发的质的变化，导致Android极度的变软了。但是，移动app和web浏览器的页面，二者还是有一个操作习惯、UI特点、以及其他效果的本质区别的，都不是技术角度的差异。所以HTML5本身是想一套UI在pc浏览器，手机、平板移动端显示效果，但是具体实现，所以实际开发，移动app虽然HTML5替代了很多内容，但是还是UI给程序员一定的繁琐。





移动端： easy 技术⁪角度没有新的脚本加入
功能： 只有学生登录，choose一个企业专业，整体核心的交互db的操作功能
     其次，给学校 or 企业 宣传，or 留言，  UI效果，超级发挥想象力，比如朋友圈UI，比如视频播放，比如转发朋友圈，微信朋友，
    

检查：
1. UI 程序员有一个体验度的感觉，模板logo变，变一个学校logo，
2. 程序逻辑，如果拿一个企业开发功能的标准衡量，功能的完成，缺陷，瑕疵还得比较多的
关键：
1. 报错，时时会遇到的，最关键的是项目的整体的流程，衔接，已经承上启下的连接，脑子必须门清的。
2. 自信，学习态度，感觉，
    


移动端app 发布，手机平板显示，
1.手机，平板移动端，和pc 一定是一个ip号段的，因为Tomcat不是电信，Tomcat夸一个号段就不能访问了
2.同一ip号段，(1).如果有一个路由，pc 和 手机同时连接一个WiFi那么路由就是发布的服务器
                       (2).视为pc 是一个服务端，发布一个WiFi，手机 or 平板连接WiFi，那么手机和pc 是一个号段，pc防火墙 pass


35天

springioc springmvc(后续大家移动端client) 5天    
ssm整合+layui企业端  5  
oracle 4天左右                      
springboot springcloud 5天
vue 5天至少
nodejs MongoDB     
python 


IO  NIO  都是文件流技术开发，项目开发比例不大，但是肯定会有

多线程 Thread Runnable  --线程锁，

多线程连接池，mybatis核心的jar比多线程连接池更加复杂



多线程：
Thread Runable 基本操作
run....

很多新启动的项目spring为代表的框架，参与很多了，涉及到多线程相关的操作不多了，框架肯定涵盖了多线程的操作模式。如果面试考核多线程，那么说明项目涉及框架开发的比例不是很多

涉及概念

cpu 进程 线程  任务栈  服务  同步锁

多个线程包含于一个进程内，


多个任务同时启动了，word txt 画图，音乐，在任务管理器中形成了任务栈
a：也就是如果是当前操作的程序，那么任务是置顶。如果操作其他程序，当前操作的任务最小化到状态栏，叫任务挂起，绝对不是任务销毁。任务的是否置顶是来回切换的
此时，涉及到的技术点太多了，比如，内存缓冲。
当其他任务置顶(当前画图指的是画图操作置顶)，之前的任务被最小化，也就是挂起任务，那么此时，该线程不能销毁，也就是保证当前被挂起的线程有任务和线程的生命周期，那么需要保护生命周期才能使得线程是再一点击后置顶，依旧可以立刻显示操作状态，所以需要保护线程和保护任务的证明周期。
第一保护线程的是缓冲，内存。在缓冲内存的过程中，涉及到一个服务启动，

b.音乐的启动，利用线程，启动音乐服务。也就是音乐始终是被挂起的，但是音乐的服务始终是启动的，所以背景音乐始终是有的。
服务是同样的操作来回的内在的循环，保证线程的运行效果，但是服务是绝地耗费内存资源的。


synchronized： 四种模式
1.this
相对有序的顺序执行：不同的new实例对象，同时顺序的执行，交替的线程比例较大但是如果是不同new实例，交替执行
2.synchronized (Ticket1.class)
和this有点相似：交替的同时开始和结束因为xx.class和线程new实例不是一个new对象的是属于不同的实例。
3.synchronized (new Object())
Object new对象：传递的不同的new实例的线程，都可以视为是Object的子类,总体还是交替执行的. Object类锁，就会拦截所有操作线程，只能一个访问
4.独立的synchronized方法，单纯的单例模式的执行的方法。
 和操作线程的对象无关，

synchronized总结还是有明显的缺陷的，
1.等待的线程管理，synchronized是无法执行的
2.执行单独的一个线程访问的时候，如果抛异常，那么就等于死锁，也就是线程的阻塞了，后续线程都无法进入了，就有些类似同步机制。
创建一个锁的模式开发单例的多线程模式



反射：
理解明显别OOP面向对象上升一个难度，反射的本身它是一个理念，不是一个技术，更不是一个框架技术。产生 了一个操作技术，工作流，
 
                                                                网络办公，办公自动化  OA项目
单线程，jdbc 直连， 多线程模式--> EJB   -->    (反射)  工作流     -->框架技术 -->云
(反射)  工作流：伴随的是一门熟练操作技术：解析XML

XML 可扩展性标记语言  3个核心的特点，全部都是非常实用性的优势
1.自定义标签，也就是标签是灵活的，符合工作流的操作模式
2.标签是有存储性质的，手机存储，电话簿，存储是利用自定义标签的效果的
 <user tel="" address="" ...>
3.不参与程序的编译，项目发布的时候xml还是原始的效果，javaweb项目，.java编译为.class，但是还需要不能参与编译的文件，会使得项目的开发更加灵活的随意，
缺点：
解析繁琐，就给工作流带来了繁琐了。properties解析简单


技术链条，都精通的no一个人，但是项目经理要求的程序员有一个具备一个什么特点:
对于一个新的技术掌握，操作，开发，维护，能够最快速度，尽快的搞定，这里最重要的一个原因是一个程序员看到一个新的从来没听说过的一个技术，发掘新的技术和之前的我ok的技术融通的地方是哪些，因为深知一个特点，一个新的技术，一个新的框架，绝对不是凭空而生的，而是都是在之前的技术逻辑基础上衍生的，也就等于新的技术怎么都会有感觉到和之前我了解的技术融通的、相似的部分是哪些，那么就会联系在一起，就会承上启下的思路去领悟技术的逻辑，产生效果的运行的结果，那么内心多少知道了技术的缘由和过程...，重要的因素 悟性

预习新的技术：看百度百科，文字还是非常接近api，而且是初学者看懂的文字，其次，看官网api，或许是English，尽量去看； 看一些论坛，案例，尤其类似csdn论坛，和博客。CSDN论坛博客，全都是项目经理的角色的人编写的，有技术含量的。但是不利的是确实很多文字是相似的有转发的。

springioc:  发动机
汽油机原理：反射机制
操作零件： xml，java OOP的操作逻辑


JAVA反射机制是在运行(javaweb项目Tomcat发布的)状态中，对于任意一个实体类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意方法和属性；这种动态获取信息以及动态调用对象方法的功能称为java语言的反射机制。

发布中，所有的，任意调用， 动态掉的方法 称之为~  ：灵活性



Java的反射机制允许编程人员在对类未知的情况下，获取类相关信息的方式变得更加多样灵活，调用类中相应方法，是Java增加其灵活性与动态性的一种机制。

反射：光看定义，有一种反射和当前javaweb项目和即将重点spring框架，是独立的没有什么关联的。关联实质是企业开发的维护的角度密不可分的。起源还是多态



IUser user=new UserImpl();


user=new UserImpl1();

接口动态模式多态的体现，一个接口new 两个对应的实现类，
那么调用范围是一样的， 方法全部一样的范围，但是方法体是绝对不同的两个出处的实现类，多态体现，总体的来说还是一个new对象衔接一个实现类的操作连接，反射的定义核心一个new对象能够灵活的动态的连接多个实现类，从而在发布的状态下，灵活的修改连接操作的实现类。所以这里有一个实际项目维护的考量。


实际维护中，新添加的功能模块遇到的问题是 一个new对象只能调用一个类对象，别管是否属于一个接口，核心的问题在于，java面向对象的new的方式弊端，new对象只能针对一个类来操作，只能针对一个实现类来操作调用，无法灵活的变换调用的指针方向。解决方案，1 调用哪个类new哪个类对象，操作如果是java独立完成，但是一个繁琐的工厂模式开发逻辑，2 有多个是实现类，那么在调用的时候new 多少个new对象，一个new对象负责一个类对象的调用，能够解决的，但是过程解决的还是过于繁琐。但是两种解决方案都不是合理的方案，也都不是时候当前javaweb开发方案，因为都是一个spring的逻辑叫高耦合的模式，也就是牵一发而动全身的模式，新添加的一个类对象，那么其他的类对象都会多少跟随修改，变化，从新调试的，叫高耦合的操作逻辑，不是最合适和适合的一种开发模式，和一种最节省的开发成本维护方式。spring：低耦合，高内聚； 第二插拔式的。一个新的功能添加，类似给火车添加一节车厢，其他车厢和车头不受丝毫影响，所以低耦合高内聚，程序逻辑直接是横向的aop的模式，不是纵向的相互约束影响依赖的纵向面向对象的模式。他们直接相互调用，又互补干扰，每一个新添加的功能类似一个新插入的一节车厢一样，插拔到新的列车中，插入的车厢都是有价值和调用可能性的类，如果没有，拔下，其他车厢不受影响。

解决的途径：
1.接口的多态，还是new的依赖模式
2.反射机制：没有new 的模式，
 IUser user=null;
  user.methos(); // 调用的方法，看得出来具体是哪个实现类的？
  所以这是一个没有new的、动态模式的、利用java核心的两个操作Object Class类实现类的一种反射机制的调用过程
 思路类似于JD 代理对象的案例，JD类中看不出具体客户购买的是哪种品牌的笔记本电脑，反射的一种雏形。
 如果new的方式，那么调用者和被调用者直接是固定的搭配关系，new的相互关联左右关系是在运行状态中无法改变的，更不能一个new对象运行状态中去同时分次调用两个实现类的操作模式，这种模式高耦合的模式，不适合更广范围的项目维护操作。所以不通过new，那么在没有指针函数的情况下，通过java两个核心操作对象Class Object，来实现动态反射机制的调用关系

回顾一个技术点，
父类  对象=new 子类();
子类  对象1=new 子类();
子类独有的new对象调用范围>= 其他对象的.......
那么接口，父类，抽象父类，价值？当时说 接口，抽象父类等是管理局限于实现类子类的操作调用范围的，所以局限性的范围在范围的范畴内价值.....


invoke动态的调用方法，涉及的技术体现非常广：
1.连接池，实际的动态连接池开发，还是一个多线程+反射 --> 容器，
2.Struts2 拦截器机制，
3.hibernate mybatis
只要有xml配置文件参与，反射机制八成少不了，解析xml，动态执行程序的，代表Struts2
<action id="sss.action" method="SaveOk">

new."SaveOk"();


最具代表性的  XML解析，多线程连接，反射机制   Struts2，工作流
反射是主语是机制，不是一个框架技术，
机制上升到一个框架的时候，那么包裹很多技术的外层，也就是框架技术，单纯的用反射机制很少的，但是框架技术都是涉及和包含反射的
Struts2 核心是拦截器

反射机制，非常给力的技术机制，但是上升到框架技术，并且应用到项目开发，是需要一个过程的。中间至少得有一个技术的包裹，动态代理模式，也是Struts2拦截器核心的技术体现，其次是XML多重模式解析，工作流的核心


工作流：从反射发展开始，有几个标志性的技术结果，动态代理，Struts2拦截器，工作流：成为反射切面开发的一个分支。期初的开发比较繁琐的一个过程，


Struts2 ， Apache  核心拦截器机制，3中，单独拦截器，多拦截器，限定方法拦截器
hibernate   红帽    OR-mapping对象关系映射，讲究不会sql语句的人完全可以实现 
insert delete......操作种类和流程，比mybatis更加繁琐


spring：名词 涉及包含n个框架  商业
总体，2004，发表论坛，轰动，IOC容器的功效
实用价值ok，适合初学者，照顾你之前传统的开发逻辑思维，能顺利的嫁接到springioc的模式来
1.springioc  企业级整合框架
  低耦合高内聚，插拔式
 控制翻转，依赖注入
2.springmvc 前台跳转， servlet 80%一样的
  出发点：继承servlet的优势，摒弃servlet的缺陷。
 最大的特点：方法的参数利用是超级灵活的，和全面的
3.springsecurity 权利拦截，全部菜单都显示，点击没有权限菜单提升"没权限 x秒跳转.."
4.springjdbc jdbc基础上创建model模式，和多线程连接池
5.springaop 切面拦截，在Struts2的拦截器基础上继续更加灵活的配置拦截机制
6.springbean  和ioc融入一起，


ssm

springboot 高度封装的整合的一个架构，商业目的
springcloud 微云项目单独项目组的整合，现阶段加入了很多插件工具






控制翻转，依赖注入

ioc的容器：
1.启动容器，多线程，始终是启动的状态中
2.加载核心的配置文件，
  (1).所有的类对象加载到该配置中，
  (2).相互的调用关系依赖的注入各自<bean>中
  ....
3.加载配置文件中的<bean>的注入效果，并且创建各自反射实例对象
4.接收操作的bean对象，把反射实例Object对象返回给操作的类对象


所以插拔式：
如果发布后，新添加一个功能逻辑，那么只需要app..xml中注册new <bean>
背后的操作和new关联很小

ioc：
控制翻转:
   链条： 接口-->接口模式开发-->反射机制-->....
   一系列的之前的铺垫
                
new <bean> ： spring核心的理念：让初学者容易的从之前new oop思想的基本模式顺利的一个固有的思路，来嫁接到ioc的new bean的模式
  1.普通new bean
    <bean id class>
  2.@ 模式 注解：
    @永恒的特点： 开发便捷，最大的缺点，跟随java编译.class
   所以实际的开发最实用的是，具体问题具体看到底是否经常变动与否，也就是XML+@开发
  3.工厂模式  easy  完全可以用new方式理解
    (1).普通工厂模式
    (2).static静态工厂模式
依赖注入
   (1).setter注入，利用封装的机制setter，启动ioc容器，默认动态调用setter方法
   (2).构造函数注入：第一程序员习惯，第二，同时可以注入常量，第三有一个缺点也是符合new的操作模式

   (3).@注入  springioc springmvc ssm springboot 都是适用的。
   (4).工厂模式依赖注入

项目案例：springioc+mybatis整合+springmvc

工厂模式：接口模式开发，工厂比如一接口，n个实现类，
一个new对象对接的只能是一个实现类的调用，oop接口模式开发的核心点，
如果动态的，也就是在多态机制的基础上，继续用非new的模式动态调用各个实现类，那么工厂模式来完成。但是new肯定存在的，存在工作的方法中，


自动装配byName常用的，easy的

byType 容易发生冲突的，慎用，如果该接口多个实现类，那么各个实现类type是一样的，装配？



@注解注入，非常符合程序员的一个心理：
比如有些角色的对象，比如实现类、XML mybatis mapper配置、mapper接口、Controller实现类(springmvc自定义类对象、方法) 都是随着项目的延申、维护、拓展而非常有可能不断开发和扩大的。这些不断扩大的类数量，虽然springioc控制类对象的ioc模式切换和调用的，但是不希望每写一个类对象、xml配置、mapper接口，都得跟随着在核心ioc配置中多加一条配置。
在ioc配置文件中，注入、注册、声明一个区间，一个批量的范围，在该范围内，所继续扩大的类对象、xml配置，都无须在ioc的配置文件中新注册一条记录。



spring的常见的错误，从后向前看，核心错误都在最后体现了
Exception in thread "main" org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name 'us2': Unsatisfied dependency expressed through method 'setComs' parameter 0; nested exception is org.springframework.beans.factory.NoUniqueBeanDefinitionException: No qualifying bean of type 'com.spring.model.IComps' available: expected single matching bean but found 2: coms,coms1
	
意思：
@Autowired依赖注入的一个@，标注在IComps接口变量之上，默认执行该接口的第一个实现类，没有异常。但是如果标注在setter方法之上了，提示了setter方法是有一个参数的，没有赋值，但是@Autowired注解默认下属有两个实现类，所以自动装配了type属性，提示的错误是，@Autowired标注的setter方法中的参数接口的对象，IComps接口下有两个匹配type的参数，不知道对应赋值哪个实现类Object对象了，抛异常了


spring的ioc解析，选修的性质，
xml的dom4j解析，ssm之后添加一案例了

springmvc：
   官网api案例，80%都是servlet的内容
  
springmvc  吸收servlet优点，smvc借鉴了太多springmvc的程序逻辑
1.前台页面跳转的框架  struts x 
 都需要web项目核心的配置文件的入口配置，web.xml
 <servlet>

2.app...xml:
springmvc 3个核心的操作类对象
  DispatcherServlet s; //入口 servlet
  InternalResourceViewResolver r;  解析视图类对象springmvc核心操作的一个对象
 AnnotationMethodHandlerAdapter a; springmvc要@配合mvc试图操作，那么需要相互配合操作，
  SimpleUrlHandlerMapping  官网案例推荐，程序员不经常操作的
  URL参数映射配置



核心的springmvc配置

1.页面的衔接和跳转的设置需要两个对象的注入
2.也包含了，IOC+httpservlet+springmvc 3个部分
配置有些整合ok，有些是没有整合ok，需要手动的配置注入操作的

整合ok的指的是，mvc内核如果是可以new和httpservlet衔接的，无需配置，但是有些不是new 连接的反射实例对象连接的，那么就需要IOC的注入配置如同
InternalResourceViewResolver

3.之前ioc测试：ApplicationContext ac=new Clas...
 启动ioc容器的，但是现在web项目启动，势必还需要ioc容器的，如果web Tomcat启动没有所有的铺垫ok，那么@RequestMapping("/web2")没有效果的，
所以ssm 项目势必启动ioc容器，而且势必肯定不是ApplicationContext ac 启动容器的
所以该配置也是有启动ioc容器的性质



如果不用application;json的话传递参数的格式不是json，是key=value&key2=value2   ,这种形式不需要加requestbody也不需要序列化。序列化后的参数是json格式，也就是一种text文本，这时就需要加上application;json 告诉后台以json格式接收，所以必须加上requestbody，因此key=value&key2=value2无法传递复杂的数据



8月底9月初正式，系统演示，每个人20分钟，毕设答辩相似


1.DB mysql
2.2个服务端，3套前段
   一个是mybatis+springmvc/servlet    前段  学生和教师端，  和   移动学生端
   另一个是SSM(周一)服务端， 前段  layui 企业端
    下周开始麻烦点还是layui脚本
3.开发的难点：不是基本讲解基础技术知识时候的感觉了
 (1). DB mysql SQL语句  sql语句，上项目才知道sql实力的提升需要... 
 (2). 服务端  SSM  springmvc mybatis servlet session jstl EL 表达式
    难点：  SSM  springmvc mybatis 框架技术，很多的技术框架领悟的过程。
           其次：接触到java数据加工的深入， chart图，json数据的加工
            加上算法存在的，+ UI前端，激励推荐，只有院长角色登陆才能操作，UI
 (3). 前段      JavaScript jQuery bootstrap vuejs  layui
     用户体验度，是一个感觉，
     还有，脚本调试，细节的调试企业是肯定的，甚至UI工程师，还要改写底层的js或者css，bootstrap.js .css,  具体实际企业开发分几层难度
    比如，项目原始全部jQuery原始开发，or 之前easyui，现在layui， 
 
终极难度的一个案例：飞行棋的动态用户

后两周玩转的核心ssm 和 layui  企业PC端，java数据加工，SQL语句难度不大的。


基础java UI基础按部就班，javaweb项目深入独立，真材实料开发，然后后期的SSM springboot springcloud，vuenpm python nodejs MongoDB

调剂算法思路还是最重要的：
1.肯定自信，乐趣感觉必须肯定会搞定它
2.不是一次性搞定结果的，如乘法表，不是一次性的那么层层剖析
 也就是分析分几步操作逻辑，第二每一步完成调试，
3.涉及功能逻辑，还会涉及哪些效果，和逻辑，比如涉及到的多方的功能，
 比如一个企业一个专业是83，院长调剂-3， 那么企业再登录显示该专业的人数？83
 也就是企业登录以后显示的是还是83，但是需要在限时范围内减去3个，否则随机-3，
 院长绝对人数，的但是具体- or + 哪个学生，那么是线下运作，线上限时操作的结果
 涉及到配套的两个前端显示的效果功能，
 第一当然院长调剂更改后平均分配的人数显示，院长依旧可以手动更改。UI是在bootstrapTable上编辑操作，
 第二企业端，显示的当前该企业所对应各个申报的专业以及已经选好的学生人数和各自的学生记录。 涉及到UI效果，treetable

当前java算法，核心的还是自信，层层剖析功能的逻辑
1.获取数据信息，所选人数（添加大量的测试数据，选该企业专业83，那么对应stus表83以上的学生记录信息，excel批量....）一开始数据[]测试，但是2问题不能用[]，原因：第一数据来源是List<Map>， 人数紧紧对应企业name和专业name，也就是人数还是唯一性的， 第二后期java数据加工时候肯定需要给数字添加一个状态标识符
2.思维逻辑：固定的两个因素：
  (1).40个人一班，那么是一个常量，
  (2).算法调剂，总体的所选的人数不能变，比如该学校已选的企业专业的人数是125个，125个人，不平均的分配给各个企业专业中去，人数调剂后，总的人数还得是125，
  (3).调剂完之后，不符合一个班40个人的专业只有一个，
3. 那么在固定的两个因素基础上，选的企业专业的数字，分析后，结果是4种，就和人数趋向小 的一个方面方向
  也就是调剂的基础参考因素是4种：拿 120 100 90 78 105 84  为例  40人一班
  120不用调剂，%40==0  第一种结果
  100暂且不用调剂，因为上下人数是一样的，+20 -20都是一样的，  第二种
   90      -10    -10                                        需要 - 的人数  第三种
  78       +2     +35                                              +                四
 当前算法逻辑的第一层要完成任务，不是最终改变数字，是需要告知集合，是哪种方式，具体应该做+ or -  map.put( “+ or -      or  100的error”，该+ or -的数字 )
4.在最初集合List<Map>每一个map put对应的状态，和应该+ or -的数字
  并且，计算总体应该+  or  +的总体的数字
5.所有的该+   or -的人数都需要拿  100人数的专业找齐，因为总人数不能+1 or -1
  所以人数 100的这种情况是平衡其他专业需要+  or  需要-的人数的，但是前提是有一个100人数的专业，如果没有那么只能是循环判断最后一个专业人数不能整除40
 也就是最终呈现给院长的人数只有一个专业是不能整除40
 开始调剂，入手的最先考虑的因素：
 也就说算法功能，第一考虑层层剖析，第二调剂的时候必须考虑到最先考虑的因素，也就是入手考虑的因素是什么，总体该+  or -的人数差，考虑总体该+ 人数 是否大于 该+的人数，还是反之，第二考虑100数字是否存在了。 
  
100人数待宰，但是数字调剂最多平衡也就是20的，也就是100最多+20  or  -20

调剂总体是5种可能性 ：总体+ - 是等于第一种，第二、三中
加>减  看是否有100人数的待宰
第四、五种：加<减  看是否有100人数的待宰
实际情况最常见的是还是没有100人数的情况中，加 减不等于的情况下 



35
8  12  11  4  需要加的人数
但是总体能够满足+的人数30，所以调剂后的人数结果：
需要加的人数：    8  12  11  4    --冒泡排序
最终调剂后人数    8  12  10  0
11
10 的时候result的值是1，调剂后，result就是0了

如果没有100数字人数那么调剂差异或许更大
比如该加的人数是35  该减的人数的是10
所以最终该加的人数满足result值是10，甩25人数不能整除40了

算法案例该完善2个点，
1.原始的数字，和调剂后的数字都需要呈现给院长，不能光显示调剂后的数字，
2.冒泡排序，最大限度的满足最终只有一个数字不能整除40

bootstrapTable双击改变编辑状态，脚本的缺陷：
1.当第一次双击可以修改的那一列数值的时候，显示之前的没有调剂之前的数字综合，逻辑不如首页第一次显示所有没调剂的人数总和，
2.点击左上角提交的按钮，提示模态框，显示之前人数。调剂后并且院长手动修改后的列表总和数字，两个数字如果不一样，肯定不能显示提交按钮，否则手动修改后的数字和之前选的人数，如果一直可以提交。



如果修改后的数字和调剂之前的数字等于的，点击提交的时候，不要改变原始选的数字，告知企业对应的记录，也就是comps表添加一类字段
如果和之前的数字有变化，那么告知对应的企业，该字段，应该+ x 还是 - x
企业登录的自身的pc端的时候，显示该+ or -，然后下线沟通，企业自己pass对应数量的学生，还是学生自己update另外一个企业的专业















